#!/usr/bin/python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Updates the snapshot of Chromium in the Android tree. See the output of
# --help for details.


import optparse
import os
import re
import subprocess
import sys
import urllib2


REPOSITORY_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
AUTOGEN_MESSAGE = 'This commit was generated by webviewchrome/snapshot.py.'

sys.path.append(os.path.join(REPOSITORY_ROOT, 'android_webview', 'tools'))
import webview_licenses

# List of projects that need to be merged to build WebView.
# We don't reuse the list from the Chrome merge scripts, because it doesn't
# contain repositories that are simply fetched from upstream, and we don't need
# the other repositories used to build the Chrome app.
THIRD_PARTY_PROJECTS = [
    'googleurl',
    'sdch/open-vcdiff',
    'testing/gmock',
    'testing/gtest',
    'third_party/WebKit',
    'third_party/angle',
    'third_party/cacheinvalidation/files/src/google',
    'third_party/freetype',
    'third_party/hunspell',
    'third_party/hunspell_dictionaries',
    'third_party/icu',
    'third_party/leveldatabase/src',
    'third_party/libjingle/source',
    'third_party/libjpeg_turbo',
    'third_party/libphonenumber/src/phonenumbers',
    'third_party/libphonenumber/src/resources',
    'third_party/libphonenumber/src/test',
    'third_party/openssl',
    'third_party/ots',
    'third_party/pyftpdlib/src',
    'third_party/skia/include',
    'third_party/skia/gyp',
    'third_party/skia/src',
    'third_party/smhasher/src',
    'third_party/v8-i18n',
    'tools/grit',
    'tools/gyp',
    'v8',
]

# Based on clank/tools/merge/deps.py but updated to use .DEPS.git
def _ParseDEPS(git_url, sha1):
  """Parses the .DEPS.git file from the specified Chromium branch at the
specified SHA1 and returns a dictonary of its contents.
  Args:
    git_url: The URL of the git server for the Chromium branch to merge to
    sha1: The SHA1 to merge to
  Returns:
    A dictionary of the contents of .DEPS.git at the specified revision
  """

  class FromImpl(object):
    """Used to implement the From syntax."""

    def __init__(self, module_name):
      self.module_name = module_name

    def __str__(self):
      return 'From("%s")' % self.module_name

  class _VarImpl(object):
    def __init__(self, custom_vars, local_scope):
      self._custom_vars = custom_vars
      self._local_scope = local_scope

    def Lookup(self, var_name):
      """Implements the Var syntax."""
      if var_name in self._custom_vars:
        return self._custom_vars[var_name]
      elif var_name in self._local_scope.get('vars', {}):
        return self._local_scope['vars'][var_name]
      raise Exception('Var is not defined: %s' % var_name)

  tmp_locals = {}
  var = _VarImpl({}, tmp_locals)
  tmp_globals = {'From': FromImpl, 'Var': var.Lookup, 'deps_os': {}}
  deps_content = _ReadGitFile(git_url, sha1, '.DEPS.git')
  exec(deps_content) in tmp_globals, tmp_locals
  return tmp_locals


def _GetCommandStdout(args, ignore_errors=False):
  """Gets stdout from runnng the specified shell command.
  Args:
    args: The command and its arguments
    ignore_errors: Ignore the command's return code
  Returns:
    stdout from running the command
  """

  p = subprocess.Popen(args=args, cwd=REPOSITORY_ROOT, stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)
  stdout, stderr = p.communicate()
  if p.returncode == 0 or ignore_errors:
    return stdout
  else:
    print >>sys.stderr, 'Running command %s failed:' % args
    print >>sys.stderr, stderr
    raise Exception('Command execution failed')


def _ReadGitFile(git_url, sha1, path):
  """Reads the specified file from the specified git project at the specified
  SHA1
  Args:
    git_url: The URL of the git server
    sha1: The SHA1 at which to read
    path: The relative path of the file to read
  Returns:
    The contents of the specified file
  """

  # TODO: We should set up a ref to the main repository's FETCH_HEAD to avoid
  # fetching it multiple times.
  _GetCommandStdout(['git', 'fetch', git_url])

  args = ['git', 'show', '%s:%s' % (sha1, path)]
  return _GetCommandStdout(args)


def _GetThirdPartyProjectMergeInfo(third_party_projects, deps_vars):
  """Gets the git URL for each project and the SHA1 at which it should be
  merged.
  Args:
    third_party_projects: The list of projects to consider
    deps_vars: The dictionary of dependencies from .DEPS.git
  Returns:
    A dictionary from project to git URL and SHA1 - 'path: (url, sha1)'
  """

  # We get the git URL and SHA1 from .DEPS.git.
  # Note that the merge tool gets the list of git URLs and SHA1s by getting SVN
  # revisions from DEPS, looking up the git URL from a manually maintained
  # list, then searching the log for the SVN revision to get the SHA1.
  # - The merge tool uses the full WebKit repository, whereas we use
  #   WebKit_trimmed.git. The only difference is that the latter excludes some
  #   ancient history.
  #
  # TODO: Some of these third-party repositories may not build for Android if
  # we have downstream edits. We should consider pulling from the Clank
  # downstream repository as an intermediate solution if this is a problem and
  # upstreaming is some way off.

  deps_fallback_order = [
      deps_vars['deps'],
      deps_vars['deps_os']['unix'],
      deps_vars['deps_os']['android'],
  ]
  result = {}
  for path in third_party_projects:
    for deps in deps_fallback_order:
      url_plus_sha1 = deps.get(os.path.join('src', path))
      if url_plus_sha1:
        break
    else:
      raise RuntimeError(
          ('Could not find .DEPS.git entry for project %s. This probably '
           'means that the project list in snapshot.py needs to be updated.') %
          path)
    match = re.match('(.*?)@(.*)', url_plus_sha1)
    url = match.group(1)
    sha1 = match.group(2)
    print '  Got URL %s and SHA1 %s for project %s' % (url, sha1, path)
    result[path] = {'url': url, 'sha1': sha1}
  return result


def _CheckNoConflictsAndCommitMerge(commit_message):
  """Prompts the user to resolve merge conflicts then once done, commits the
  merge using either the supplied commit message or a user-supplied override.
  Args:
    commit_message: The default commit message
  """

  status = _GetCommandStdout(['git', 'status', '--porcelain'])
  conflicts_deleted_by_us = [x[1] for x in re.findall(r'^(DD|DU) ([^\n]+)$',
                                                      status,
                                                      flags=re.MULTILINE)]
  if conflicts_deleted_by_us:
    print 'Keeping ours for the following locally deleted files.\n  %s' % \
        '\n  '.join(conflicts_deleted_by_us)
    _GetCommandStdout(['git', 'rm', '-rf', '--ignore-unmatch'] +
                      conflicts_deleted_by_us)

  while True:
    status = _GetCommandStdout(['git', 'status', '--porcelain'])
    conflicts = re.findall(r'^((DD|AU|UD|UA|DU|AA|UU) [^\n]+)$', status,
                           flags=re.MULTILINE)
    if not conflicts:
      break
    conflicts_string = '\n'.join([x[0] for x in conflicts])
    new_commit_message = raw_input(
        ('The following conflicts exist and must be resolved.\n\n%s\n\nWhen '
         'done, enter a commit message or press enter to use the default '
         '(\'%s\').\n\n') % (conflicts_string, commit_message))
    if new_commit_message:
      commit_message = new_commit_message
  _GetCommandStdout(['git', 'commit', '-m', commit_message])


def _MergeProjects(git_url, svn_revision, root_sha1):
  """Merges into this repository all projects required by the specified branch
  of Chromium, at the SVN revision. Uses a git subtree merge for each project.
  Directories in the main Chromium repository which are not needed by Clank are
  not merged.
  Args:
    git_url: The URL of the git server for the Chromium branch to merge to
    svn_revision: The SVN revision for the main Chromium repository
    root_sha1: The git SHA1 for the main Chromium repository
  """

  # The logic for this step lives here, in the Android tree, as it makes no
  # sense for a Chromium tree to know about this merge.

  print 'Parsing DEPS ...'
  deps_vars = _ParseDEPS(git_url, root_sha1)

  merge_info = _GetThirdPartyProjectMergeInfo(THIRD_PARTY_PROJECTS, deps_vars)

  for path in merge_info:
    url = merge_info[path]['url']
    sha1 = merge_info[path]['sha1']
    print 'Fetching project %s at %s ...' % (path, sha1)
    _GetCommandStdout(['git', 'fetch', url])
    if not os.path.exists(os.path.join(REPOSITORY_ROOT, path)):
      print 'Path %s not present, creating' % path
      _GetCommandStdout(['git', 'read-tree', '--prefix=%s' % path, '-u', sha1])
      _GetCommandStdout(['git', 'commit', '-m',
                         'Add %s from %s at %s\n\n%s' %
                         (path, url, sha1, AUTOGEN_MESSAGE)])
    if _GetCommandStdout(['git', 'rev-list', '-1', 'HEAD..' + sha1]):
      print 'Merging project %s at %s ...' % (path, sha1)
      # Merge conflicts make git merge return 1, so ignore errors
      _GetCommandStdout(['git', 'merge', '-Xsubtree=' + path, '--no-commit',
                         sha1], ignore_errors=True)
      _CheckNoConflictsAndCommitMerge(
          'Merge %s from %s at %s\n\n%s' % (path, url, sha1, AUTOGEN_MESSAGE))
    else:
      print 'No new commits to merge in project %s' % path

  # Handle root repository separately.
  print 'Fetching Chromium at %s ...' % root_sha1
  _GetCommandStdout(['git', 'fetch', git_url])
  print 'Merging Chromium at %s ...' % root_sha1
  # Merge conflicts make git merge return 1, so ignore errors
  _GetCommandStdout(['git', 'merge', '--no-commit', root_sha1],
                    ignore_errors=True)
  _CheckNoConflictsAndCommitMerge(
      'Merge Chromium from %s at r%s (%s)\n\n%s'
      % (git_url, svn_revision, root_sha1, AUTOGEN_MESSAGE))

  print 'Getting directories to exclude ...'
  directories_to_exclude = webview_licenses.GetIncompatibleDirectories()
  print '  %s' % '\n  '.join(directories_to_exclude)
  _GetCommandStdout(['git', 'rm', '-rf', '--ignore-unmatch'] +
                    directories_to_exclude)
  _GetCommandStdout(['git', 'commit', '-m', 'Exclude incompatible directories'])

  return True


def _GenerateMakefiles(svn_revision):
  """Run gyp to generate the makefiles required to build Chromium in the
  Android build system.
  """

  print 'Regenerating makefiles ...'
  # TODO(steveblock): The .tmp files are generated by
  # third_party/WebKit/Source/WebCore/WebCore.gyp/WebCore.gyp into the source
  # tree. We should avoid this, or at least use a more specific name to avoid
  # accidentally removing or adding other files.
  _GetCommandStdout(['git', 'rm', '--ignore-unmatch', 'GypAndroid.mk',
                     '*.target.mk', '*.host.mk', '*.tmp'])

  _GetCommandStdout(['bash', '-c', 'export CHROME_ANDROID_BUILD_WEBVIEW=1 && '
                                   'export CHROME_SRC=`pwd` && '
                                   '. build/android/envsetup.sh && '
                                   'android_gyp'])

  _GetCommandStdout(['git', 'add', '-f', 'GypAndroid.mk', '*.target.mk',
                     '*.host.mk', '*.tmp'])
  # Only try to commit the makefiles if something has actually changed.
  if _ModifiedFilesInIndex():
    _GetCommandStdout(['git', 'commit', '-m',
                       'Update makefiles after merge of Chromium at r%s\n\n%s'
                       % (svn_revision, AUTOGEN_MESSAGE)])

def _ModifiedFilesInIndex():
  """Returns whether git's index includes modified files, ie 'added' changes.
  """
  status = _GetCommandStdout(['git', 'status', '--porcelain'])
  return re.search(r'^[MADRC]', status, flags=re.MULTILINE) != None


def _GenerateNoticeFile(svn_revision):
  """Generates a NOTICE file for all third-party code (from Android's
  perspective) that lives in the Chromium tree and commits it to the root of
  the repository.
  Args:
    svn_revision: The SVN revision for the main Chromium repository
  """

  print 'Regenerating NOTICE file ...'

  contents = webview_licenses.GenerateNoticeFile(print_warnings=True)

  with open(os.path.join(REPOSITORY_ROOT, 'NOTICE'), 'w') as f:
    f.write(contents)
  f.closed
  _GetCommandStdout(['git', 'add', 'NOTICE'])
  # Only try to commit the NOTICE update if the file has actually changed.
  if _ModifiedFilesInIndex():
    _GetCommandStdout([
        'git', 'commit', '-m',
        'Update NOTICE file after merge of Chromium at r%s\n\n%s'
        % (svn_revision, AUTOGEN_MESSAGE)])


def _GetSVNRevisionAndSHA1(git_url, svn_revision):
  print 'Getting SVN revision and SHA1 ...'
  _GetCommandStdout(['git', 'fetch', git_url])
  if svn_revision:
    # Sometimes, we see multiple commits with the same git SVN ID. No idea why.
    # We take the most recent.
    sha1 = _GetCommandStdout(['git', 'log',
                              '--grep=git-svn-id: .*@%s' % svn_revision,
                              '--format=%H', 'FETCH_HEAD']).split()[0]
  else:
    # While we're using the Clank tree, just use the latest commit.
    sha1 = _GetCommandStdout(['git', 'log', '-n1', '--format=%H',
                              'FETCH_HEAD']).split()[0]
    svn_revision = '<latest>'
    # TODO: We should just take the latest revision.
    # TODO: We may be able to use a LKGR for our branch?
    #commit = _GetCommandStdout(['git', 'log', '-n1', '--grep=git-svn-id:',
    #                            '--format=%H%n%b', 'FETCH_HEAD'])
    #sha1 = commit.split()[0]
    #svn_revision = re.search(r'^git-svn-id: .*@([0-9]+)', commit,
    #                         flags=re.MULTILINE).group(1)
  return (svn_revision, sha1)


def _Snapshot(git_url, svn_revision):
  """Takes a snapshot of the specified Chromium tree at the specified SVN
  revision and merges it into this repository. Also generates Android makefiles
  and generates a top-level NOTICE file suitable for use in the Android build.
  Args:
    git_url: The URL of the git server for the Chromium branch to merge to
    svn_revision: The SVN revision for the main Chromium repository
  """

  (svn_revision, root_sha1) = _GetSVNRevisionAndSHA1(git_url, svn_revision)
  if not _GetCommandStdout(['git', 'rev-list', '-1', 'HEAD..' + root_sha1]):
    print 'No new commits to merge from branch %s at r%s (%s)' % (git_url,
                                                                  svn_revision,
                                                                  root_sha1)
    return

  print 'Snapshotting Chromium branch %s at r%s (%s)' % (git_url, svn_revision,
                                                         root_sha1)

  # 1. Merge, accounting for excluded directories
  _MergeProjects(git_url, svn_revision, root_sha1)

  # 2. Generate Android makefiles
  _GenerateMakefiles(svn_revision)

  # 3. Generate Android NOTICE file
  _GenerateNoticeFile(svn_revision)


def main():
  parser = optparse.OptionParser(usage='%prog [options]')
  parser.epilog = ('Takes a snapshot of the Chromium tree at the specified '
                   'Chromium SVN revision and merges it into this repository. '
                   'Paths marked as excluded for license reasons are removed '
                   'as part of the merge. Also generates Android makefiles and '
                   'generates a top-level NOTICE file suitable for use in the '
                   'Android build.')
  parser.add_option(
      '', '--git_url',
      # TODO: This will be our internal Chromium branch. For now use upstream.
      default='https://git.chromium.org/git/chromium.git',
      help=('The URL of the git server for the Chromium branch to merge. '
            'Defaults to upstream trunk.'))
  parser.add_option(
      '', '--svn_revision',
      default=None,
      help=('Merge to the specified chromium SVN revision, rather than using '
            'the current latest revision.'))
  (options, args) = parser.parse_args()
  if args:
    parser.print_help()
    return 1

  if 'ANDROID_BUILD_TOP' not in os.environ:
    print >>sys.stderr, 'You need to run the Android envsetup.sh and lunch.'
    return 1

  if not _Snapshot(options.git_url, options.svn_revision):
    return 1

  return 0

if __name__ == '__main__':
  sys.exit(main())
